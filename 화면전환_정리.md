# 화면전환
프로그래밍 코드를 이용해서 화면 전환을 처리하는 방식이 1, 2번이다. '프로그래밍적으로 화면을 전환한다', '동적으로 화면을 전환한다'라고 표현한다.
반대로 스토리보드에서 구현하는 방식을 'GUI 방식으로 화면을 전환한다', '정적으로 화면을 전환한다'라고 표현한다. 둘은 서로 장단점이 있기 때문에 필요에 따라 사용하자.

## 1. 뷰를 이용한 화면 전환
* 뷰 컨트롤러 안에 두 개의 루트 뷰를 준비해서 상황에 따라 적절히 교체해주는 방식
* 하나의 뷰 컨트롤러가 두 개의 루트 뷰를 관리해야하므로 그리 좋은 방법은 아님.
* *iOS에서는 하나의 뷰 컨트롤러 아래에 하나의 루트 뷰를 관리하는 MVC 패턴을 기본으로 함*

### 뷰 컨트롤러 직접 호출에 의한 화면 전환

* 현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출. *프리젠테이션 방식.*
```swift
// 현재 뷰 컨트롤러가 present 메소드 호출
self.present(<새로운 뷰 컨트롤러 인스턴스>, animated: <애니메이션 여부>, completion: <클로저. 화면전환이 완전히 끝난 후 호출됨>)

// Unwind 할 때는 presenting 하는 주체가 dismiss 메소드를 호출하는 것
self.presentingViewController?.dismiss(animated: <애니메이션 여부>, completion: <클로저>)
```

* 기존의 뷰 컨트롤러가 주체가 되어서 다른 뷰 컨트롤러를 present 하는 방식임
* 그래서 나타낸 화면을 다시 없애는 dismiss 메소드도 기존의 뷰 컨트롤러가 호출하는 것
* 기존 뷰 컨트롤러는 presentedViewController로 나타난 뷰 컨트롤러를 참조하고, 나타내진 뷰 컨트롤러는 presentingViewController로 자신을 present한 뷰 컨트롤러를 참조할 수 있음
* 뷰 컨트롤러 인스턴스는 다음과 같이 참조할 수 있음(uvc가 메소드 내에서 필수적이니 guard 조건문으로 필터링하기 딱 좋다)
```swift
@IBAction function moveNext(_ sender: Any) {
	// 이동할 뷰 컨트롤러 객체를 StoryboardID 정보를 이용하여 참조.
	// 먼저 전환하고자 하는 뷰 컨트롤러 객체를 생성하는 부분
	guard let uvc = self.storyboard?.instantiateViewController(withIdentifier: "SecondVC")

	// 화면 전환할 때의 애니메이션 타입
	uvc.modalTransitionStyle = UIModalTransitionStyle.coverVertical
	
	// 인자값으로 뷰 컨트롤러 인스턴스를 넣고 프리젠트 메소드 호출
	self.present(uvc, animated: true)
}
```

* `UIModalTransitionStyle`은 열거형으로 화면전환 애니메이션 4가지를 가짐.  `.coverVertical`, `.crossDissolve`, `flipHorizontal`, `partialCurl`

### 뷰 컨트롤러와 .swift 클래스 연결하기
라이브러리에서 뷰 컨트롤러를 추가하면 오브젝티브-C로 작성된 UIViewController가 연결되어 있음. 이는 UIKit 프레임워크에 정의되어있어서 임의로 내용을 추가하거나 수정할 수 없음. 그래서 우리는 UIViewController를 상속받아서 코드를 추가하는 것.
* .swift로 상속받아서 코드를 작성한 뒤에, 클래스 파일과 뷰 컨트롤러를 이어줘야함.
	* 연결하고자 하는 뷰 컨트롤러를 선택하고, Identity Inspector를 열고(오른쪽에 있는 것) Custom Class 항목에서 작성한 클래스 파일을 연결해주자.
	* Class에는 해당 뷰 컨트롤러에서 연결할 수 있는 컨트롤러 클래스 목록이 나열되는데 여기에 우리가 작성한 클래스도 있다.
```swift
import UIKit

class SecondViewController: UIViewController {
}	
```

## 2. 내비게이션 컨트롤러를 이용한 화면 전환
* 내비게이션 컨트롤러는 뷰 컨트롤러의 특별한 종류로 계층적 성격을 띠는 콘텐츠 구조를 관리하기위한 컨트롤러
* 내비게이션 컨트롤러는 그 자체로는 컨텐츠가 없고 대신에 다른 뷰들을 제어하고, 얘가 제어하는 모든 뷰 컨트롤러에 내비게이션 바(상단에 있는 것)을 생성하는 특징이 있음
* *그리고 내비게이션 컨트롤러는 항상 콘텐츠 계층 구조의 시작점 ㅁ역할을하는 뷰 컨트롤러와 함께 다님. 이를 루트 뷰 컨트롤러라고 함.*
* 내비게이션 컨트롤러는 내비게이션 스택으로 뷰 컨트롤러들을 관리함. 이 스택은 배열형식으로 제일 위에 있는 게 현재 화면에 표시되고 있는 뷰 컨트롤러이다.
* push 메소드로 `pushViewController(_:animated:)` 메소드를 사용하고, pop 메소드로 `popViewController(animated:)` 메소드를 사용한다. *이 메소드들은 호출 주체가 내비게이션 바이다.*
```swift
import UIKit

class ViewController: UIViewController {
...
	@IBAction func moveByNavy(_ sender: Any) {
		
		guard let uvc = self.storyboard?.instantiateViewController(withIdentifier: "SecondVC") else {
			return
		}

		// 화면을 전환. 호출 주체는 내비게이션 컨트롤러임에 주목하자
		self.navigationController?.pushViewController(uvc, animated: true)
	}
}
```
* 스토리보드에서 내비게이션 컨트롤러를 추가할 때는 라이브러리에서 추가하기 보다는 Xcode에 있는 'Embed In' 기능을 사용하는 것이 편리하다(이미 있는 루트 뷰 컨트롤러를 내비게이션 컨트롤러의 루트로 삼는 것. 앞에 내비게이션 뷰 컨트롤러를 삽입하는 느낌)
* Xcode 에서 [Editor] -> [Embed In] -> [Navigation Controller]
* *내비게이션 바에 타이틀을 작성하기 위해선 내비게이션 아이템이라는 객체를 추가해야한다.* 이름이 헷갈릴 수 있는데, 헷갈리면 스토리보드 왼쪽의 계층구조를 보자. 추가할 아이템 종류가 적혀있다.
* *Bar Button Item*은 내비게이션 바에 추가하는 버튼이다. attribute inspector에서 아이콘을 바꿀 수 있다. 일반 버튼도 추가할 수 있지만, 편의상 가능한 거고 이럴 경우 자동으로 바 버튼 아이템으로 바뀌어서 들어간다.
* 내비게이션 탭 왼쪽을 비워두면 자동으로 이전 뷰 컨트롤러의 내비게이션 바 타이틀의 이름으로 뒤로가기 버튼이 생긴다. 그래서 비워두는 편이 편하다. 만약 비우지 않고 아이템을 넣으면 뒤로가기 버튼은 따로 직접 구현해주어야 한다.
* present 방식으로 화면전환을 한 경우에는 `dismiss(animated:)` 메소드로 이전 화면으로 돌아갈 수 있고, 내비게이션 방식은 `popViewController(animated:)` 메소드로 돌아갈 수 있다. 둘은 같이 써지지 않는다.
* 내비게이션 바는 내비게이션 컨트롤러가 뷰 컨트롤러를 제어할 때만 자동으로 생긴다. 그래서 present 방식으로 화면이 전환된 경우 내비게이션 바는 생성되지 않는다.

## 3. 세그웨이를 이용한 화면 전환
프로그래밍 방식으로 화면을 전환하는 것으로 충분할 것 같지만, 이는 스토리보드가 가지는 장점을 절반쯤 버리는 것과 같다. 스토리보드의 강점이야말로 화면의 연결과 처리에 대한 편의성이기 때문이다.
스토리보드에서는 화면의 전환과 연결 관계를 관리하는 세그웨이(Segueway) 객체가 있으므로 이를 이용해서 화면 전환을 관리하는 요령을 터득하는 것이야말로 생산성을 한껏 높이고 편리하게 앱을 개발할 수 있는 방법이다.

* 세그웨이(Segue)라고 불리는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할을 함
* 화면과 화면을 연결할 때 아무런 소스코드도 필요없음
* 뷰 컨트롤러와 뷰 컨트롤러 / 또는 화면 전환의 매개체가 되는 버튼과 뷰 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성
* 소스 코드로 화면 전환을 처리할 땐 대상(목적지)의 뷰 컨트롤러를 찾아서 직접 인스턴스화 해서 화면 전환을 하였지만, 세그웨이는 뷰 컨트롤러 정보가 필요없다. 뷰 컨트롤러 객체를 생성할 필요도 없다. 세그웨이가 스토리보드상의 연결 정보를 이용하여 대상 뷰 컨트롤러 인스턴스를 자동으로 만들기 때문
* 세그웨이가 실행되는 순간 스토리보드를 통해 이미 세그웨이의 출발지와 목적지 뷰 컨트롤러에 대한 인스턴스가 생성되고 포인터가 세그웨이 객체이 설정된다(`self.source`, `self.destination`)
* 세그웨이는 출발지가 뷰 컨트롤러 그 자체냐, 혹은 버튼이나 테이블 셀 등이냐에 따라 *매뉴얼 세그웨이(Manual Segue), 액션 세그웨이(Action Segue)로 나뉜다.*
* 이 둘은 실행하는 방식만 다를 뿐 세그웨이를 실행하기만 하면 화면전환이 이루어진다는 건 똑같다

### 3-1 액션 세그웨이
* 액션세그웨이는 트리거와 세그웨이가 직접 연결된 형태
* 보통 Button을 만들고 이를 스토리보드에서 마우스로 끌어다 다른 뷰 컨트롤러에 연결하는 식으로 만들어짐
* Show 타입이냐, Present Modally 타입이냐에 따라서 스토리보드에서 나타는 아이콘의 형태가 다르다. (+ 커스텀 세그웨이도 다르다. 이렇게 총 3가지 정도 형태가 있는 듯)
* 세그웨이를 직접 선택해서 인스펙터에서 ID도 붙여줄 수 있음
* Show는 내비게이션 컨트롤러에서만 유효하며, 내비게이션 컨트롤러가 없으면 자동으로 Present Modally 형식으로 세그웨이가 실행됨
* 참고로 스토리보드의 루트 뷰 컨트롤러는 스토리보드상에서 화살표로 지정해줄 수도 있고 어트리뷰트 인스펙터 탭에서도 지정해줄 수 있다. [Is Initial View Controller] 항목 체크로 지정함
* 내비게이션 컨트롤러와 이것의 첫 번째 루트 뷰 컨트롤러 간에 생기는 세그웨이는 관계형 세그웨이로 두 컨트롤러 사이의 연결 관계를 정의해주는 세그웨이이다. 얘도 마우스를 끌어다 정의할 수 있다.
* 액션 세그웨이는 간단하게 생성할 수 있는 장점이 있다

### 3-2 매뉴얼 세그웨이
* 매뉴얼 세그웨이는 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이이다. 액션 세그웨이는 연결해둔 해당 이벤트만 발생하면 자동으로 실행되었던 것과 차이가 있다.
* 그래서 매뉴얼 세그웨이는 소스 코드 내에서 수동으로 메소드를 실행해줘야한다.
* `performSegue(withIdentifier: <세그웨이 식별자>, sender: <세그웨이 실행객체>`
* 이때 사용되는 세그웨이 식별자는 세그웨이를 스토리보드에서 클릭해서 아이덴티파이어 인스펙터에서 ID를 지정해주어야한다. 그리고 @IBAction으로 추가한 메소드에 이 실행 메소드를 작성해주면 된다.
* 세그웨이로 화면전환 효과를 주기 위해선 세그웨이의 어트리뷰트 인스펙터에서 Transition부분을 수정해주면 된다. 프로그래밍 방식으로 화면을 전환할 때와 같은 효과를 줄 수 있다.

## UnWind
* 기존에는 dismiss(animated:), popViewController(animated:) 메소드로 unwind를 구현했다
* 세그웨이에서는 세그웨이 구조에서 제공하는 Unwind Segue를 이용하면 된다
* 스토리보드 뷰 컨트롤러 상단에 나타나는 독 바의 아이콘 중에서 세 번째 아이콘, Exit에 세그웨이를 연결함으로써 구현할 수 있다(세그웨이를 돌아가고 싶은 세그웨이로 연결하는 방식은, 소스코드에서 돌아가고 싶은 곳으로 화면을 새로 present 하는 것과 같이 잘못된 방식이다)
* *Exit에 Unwind Segue를 구현할 때는 특이한 점이 돌아가고 싶은 뷰 컨트롤러에 메소드를 정의한다는 점이다. 형식에 맞게 정의해두면 코코아 터치 시스템이 앱 내부에서 정의된 모든 메소드를 스캔하여, 이 중에서 UIStoryboard 타입의 인자값을 입력받는 액션 메소드를 모드 수집하여 리스팅한다. 형식에 맞는 건 전무 리스팅되니 이 메소드의 이름을 구체적이게 지어주는 것이 알아보기 편하고, 이 메소드 이름은 전체에서 유일해야 한다*
* 예를 들어 뷰 컨트롤러 A에 UIStoryboardSegue 타입의 인자값을 받는 @IBAction 액션 메소드를 정의하면 이것을 Unwind Segue 메소드라고 한다. 이때 메소드를 버튼과 연결할 필요는 없다
* 뷰 컨트롤러 B에 버튼을 만들고 이를 Exit 아이콘에 드래그 하면 트리거가 생성된다
* 이때 앞서 뷰 컨트롤러 A에서 정의한 메소드를 인식하고 이를 찾아 Unwind Segue로 자동 생성해 준다.
* *이 Unwind 메소드는 특별히 내부에 뭘 정의하지 않는다. 단순히 이정표 역할을 한다. 그래서 간단하게 이정표 메소드라고도 부른다.*
* 여러 화면이 겹쳐서 있더라도 이걸 이용해서 한방에 돌아갈 수도 있다.
* 주의할 점은 이정표 메소드는 돌아가려는 뷰 컨트롤러에다가 작성하는 것이다.
* 1, 2, 3, 4, 5 페이지를 내비게이션 컨트롤러에서 show 방식으로 차례로 화면전환한 뒤 이정표 메소드로 1로 한번에 돌아가면, 2 3 4 페이지는 메모리가 해제된다. 3으로만 돌아가면 4, 5만 해제될 것이다.

## 커스텀 세그웨이
* UIKit 프레임워크에서 제공하는 UIStoryboardSegue 클래스를 서브클래싱해서 우리가 원하는 새로운 기능을 추가해줄 수 있다. 이를 커스텀 세그웨이(Custom Segue)라고 부른다.
* UIStoryboardSegue 클래스에서 세그웨이의 실행을 처리하는 메소드는 perform() 이기 때문에 커스텀 세그웨이에서도 원하는 화면 전환 기능을 구현하기 위해서는 perform() 메소드를 오버라이드 해야한다.
```swift
// custom segue
// NewSegue.swift
import UIKit

class NewSegue: UIStoryboardSegue {
    override func perform() {
        // 세그웨이의 출발지 뷰 컨트롤러
        let srcUVC = self.source
        // 세그웨이의 목적지 뷰 컨트롤러
        let destUVC = self.destination
        // fromView에서 toView로 뷰를 전환한다
        UIView.transition(from: srcUVC.view,
                          to: destUVC.view,
                          duration: 2,
                          options: .transitionCurlDown)
    }
}
```
	* 세그웨이가 실행될 때 세그웨이 객체에 자동으로 출발지와 목적지의 뷰 컨트롤러가 인스턴스화 되어서 포인터로 들어가있다. 그래서 이 코드에서 참조가 가능한 것.
	* 세그웨이는 양쪽 뷰 컨트롤러 사이를 한쪽 방향으로 연결하는 객체라서 출발지, 목적지에 해당하는 뷰 컨트롤러를 가지는 것.
	* 출발지, 목적지 뷰 컨트롤러를 읽어온 뒤에는 이를 이용해서 양쪽 사이의 화면전환 방식을 정의해주면 된다.
	* 각자 구현하는 커스텀 세그에 따라 전환 방식이 모두 달라지는데, 이 예제에서는 UIView 객체의 전환 기능을 이용하는 방법이다.
	* `UIView.transition(from: <출발지 뷰> to: <목적지 뷰> duration: <화면 전환에 소요되는 시간(단위: 초)> options: <애니메이션 전환 옵션> completion: <화면 전환이 끝난 후 실행할 함수나 클로저 구문>)`
	* 이 transition() 은 타입메소드라 객체를 생성하지 않고 바로 호출할 수 있다. 
	* 지금 구현한 것은 뷰 컨트롤러 전체를 전환하는 대신 다른 컨트롤러에 있는 뷰만 읽어와서 전환하는 세그웨이이다.
	* 이를 응용하면 뷰 컨트롤러 하나에서 상태값에 따라 여러 가지 다른 뷰를 다양하게 표현하는 일이 가능하다. 상태값별로 보여줄 뷰와 뷰 컨트롤러를 작성한 다음 조건절로 구분하여 특정 조건일 때 읽어 들이는 뷰를 바꿔주면 되니깐.
	* 물론 MVC 패턴에 맞게 하나의 뷰 컨트롤러에는 하나의 루트 뷰만 제어하는 것이 좋기에 하나의 뷰 컨트롤러에서 여러 개의 뷰를 관리하지 않는 것.
* 커스텀 세그웨이는 스토리보드에서 드래그 후 액션 세그웨이를 연결할 때 Custom 타입으로 선택함으로써 적용할 수 있다. 
* *중요한 작업은 커스텀 세그웨이를 만들고 세그웨이를 선택해서 어트리뷰트 인스펙터 탭에서 클래스를 지정해줘야 한다. 마치 뷰 컨트롤러와 클래스파일을 연결해주듯이*

## 전처리 메소드(Pre-Process Method)
세그웨이를 이용하면 구현은 쉽지만 자유도가 낮다. 그래서 세그웨이로 화면 전환을 할 때 뭔가 특별한 처리를 하고 싶을 때 전처리 메소드를 사용할 수 있다.
세그웨이를 실행하기 전 값을 저장해두거나, 경고창을 띄우는 등의 작업을 해야할 때 전처리 메소드에 해당 내용을 작성해 놓으면 그 내용이 세그웨이가 실행되기 전에 자동으로 실행된다.

* `prepare(for segue: UIStoryboardSegue, sender: Any?) {...}`
* 주의할 점은 이 메소드는 호출 주체가 우리가 아니다. 우리가 구현해놓으면 시스템이 필요한 시점에 호출하는 방식이다.
* 이 메소드는 두 개의 매개변수를 가진다.
* 첫 번째 매개변수는 메소드를 호출한 세그웨이 객체이다. 하나의 뷰 컨트롤러에 연결된 여러 개의 세그웨이들 모두가 하나의 전처리 메소드를 공유하고 실행되기 전 공통적으로 호출한다. 그래서 전처리 메소드는 어느 세그웨이가 자신을 호출한 것인지를 알고 구분해야하니 그에 대한 정보가 첫 번째 매개변수로 전달되는 것. 이걸로 이제 세그웨이에 따른 조건별 작업을 처리할 수 있다
* 두 번째 매개변수는 세그웨이를 실행하는 트리거에 대한 정보이다. 하나의 세그웨이는 여러 개의 트리거를 가질 수 있다. 즉 화면 내의 여러 요소가 동일한 세그웨이를 실행할 수 있다는 뜻이다. 만약 액션 세그웨이라면 버튼이나 테이블 셀 혹은 제스처 등의 객체가 주 대상이 될 것이고, 매뉴얼 세그웨이라면 뷰 컨트롤러 자신이 인자값으로 전달될 것이다
* 전처리 메소드는 사실 UIViewController 클래스에 이미 정의되어 있다. 그래서 우리가 전처리 메소드를 작성한다는 것은 새로운 걸 작성하는 것이 아닌 오버라이드 해서 작성하는 것.
* 세그웨이를 실행할 경우 실행을 감지한 iOS 시스템이 정의된 전처리 메소드를 호출하는 방식이다. 그래서 필요한 인자값은 iOS 시스템이 알아서 넣어준다.
* 예시 코드는 다음과 같다.
```swift


class ViewController: UIViewController {
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if (segue.identifier == "custom_segue") {
            NSLog("커스텀 세그가 실행됩니다")
            // 커스텀 세그가 실행될 때 처리할 내용을 여기에 작성
        } else if (segue.identifier == "action_segue") {
            NSLog("액션 세그가 실행됩니다")
            // 액션 세그가 실행될 때 처리할 내용을 여기에 작성
        } else {
            NSLog("알 수 없는 세그입니다.")
            // 기타 세그웨이가 실행될 때 처리할 내용을 여기에 작성
        }
    }

}
```

* 세그웨이와 관련하여 이 같은 전처리 메소드는 대부분 다음 화면으로 값을 전달하는 데에 사용된다. 현재의 화면에서 입력된 값을 넘기거나, 혹은 사용자가 선택한 값을 넘기는 데에 전처리 메소드가 사용된다는 것. 전달된 값은 다음 화면에서 보다 상세한 코넨츠를 보여주는 데에 사용되거나 적어도 그와 관련된 추가 콘텐츠를 제공하기 위한 핵심 요소로 활용된다.