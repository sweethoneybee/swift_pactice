# Optional

 swift에서는 오류를 최대한 발생시키지 않으면서(발생하면 프로그램이 뻗으니깐)  프로그래머에게 뭔가 문제가 있었다는 것도 알려주기 위해 **nil** 값을 사용한다. 딕셔너리에서 없는 키값을 참조할 때와 같이, 값을 처리하는 과정에 문제가 있을 경우 스위프트는 많은 부분에서 오류를 발생시키는 대신 결과값을 **nil** 로 반환한다. 하지만 모든 타입이 nil을 반환할 수 있는 것은 아니며 옵셔널 타입만 nil을 반환할 수 있다. 

중요한 점은 "오류가 발생할 가능성"이다. 아주 조금이라도 오류가 발생할 가능성이 있다면 모두 옵셔널 타입으로 정의해야 한다. 그래서 Int("Swift")는 nil을 반환한다.(숫자 변환이 안되고, 오류 발생 안시키면서 뭔가 문제가 있다는 걸 알림)

옵셔널 타입으로 선언하기 위해서는 우리가 사용하는 자료형 뒤에 물음표만 붙이면된다.

```swift
var optInt : Int?
var optStr : String?
var optDouble : Doube?
var optArr : [String]?
var optDic : Dictionary<String, String>?
var optClass : AnyObject?
```

일반 자료형을 선언만 하고 초기화하면 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화된다. **물론, 옵셔널 내부에 있는 자료형에 nil값이 부여된다는 것이 아니라, 옵셔널 타입 자체에 nil이 부여된다는 뜻이다.**

옵셔널 타입끼리는 결합 연산, 더하기 연산이 가능한 데이터 타입이 아니고, 일반 자료형과 옵셔널은 다른 자료형이기 때문에 연산이 불가능

```swift
Int("123") + Int("123") // 불가. 옵셔널 + 옵셔널
Int("123") + 30 // 불가. 옵셔널 + 일반 자료형
```

그래서 옵셔널 객체를 해제하고 내부에 있는 값을 추출해야하는데, 이를 Optional Unwrapping 이라고 한다. 옵셔널 해제에는 명시적, 묵시적 해제가 있다. 각각 강제 해제, 비강제 해제와 컴파일러에 의한 자동 해제, !연산자를 사용한 자동 해제가 있다.

## Forced Unwrapping(강제 해제) 

옵셔널 타입의 값 뒤에 '!' 기호만 붙여주면 된다. 이때 사용된 '!'를 '강제 해제 연산자(Forced-Unwrapping Operator)'라고 한다.

```swift
var optInt : Int? = 3

print("옵셔널 자체의 값: \(optInt)")
print("!로 강제 해제한 값: \(optInt!)")
```

근데 실제로는 이렇게 막 강제 해제하면 안된다. nil을 강제 해제하면 오류가 발생하기 때문. 그래서 안전하게 사용하기 위해 조건이 따른다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검하고, nil이 아닐 때만 강제 해재 연산자로 추출하는 것이 안전하다.

```swift
var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr!)입니다")
} else {
    print("값 변환에 실패하였습니다.")
}
```

추가로, 여기서 intFromStr의 비교연산자 != 사이에 공백은 가독성을 위한 것이 아니라 의도적으로 넣은 것이다. 강제 해제 연산자 "!"와 구분하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야한다.

## Optional Binding

