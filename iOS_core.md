(여기의 내용은 '꼼꼼한 재은씨의 Swift: 기본편'의 'CHPATER 02: iOS 앱의 구조와 코코아 터치 프레임워크'의 내용을 공부하며 작성하였습니다)

# iOS 코어

OS에서도 kernel과 user로 나뉘고, 커널 인터페이스로 시스템 콜을 제공하듯이, iOS 앱도 Custom Code와 System Framework로 나뉘어서 각각 건드릴 수 있는 영역과 건드릴 수 없는 영역으로 나뉜다. 앱은 우리가 작성하는 커스텀코드와 시스템 프레임워크 사이에서 매우 복잡한 상호작용을 한다. 시스템 프레임워크는 iOS 기반의 앱이 실행하는 데에 필요한 기반 환경을 제공하는 역할이다.

앱은 기본적으로 시스템 프레임워크가 정의한 원리에 의해 동작하고 그 외에는 우리가 정의해서 구현할 수 있는 것이다. 이 말은 곧 우리가 신경쓸 부분만 잘 신경써주면 앱은 잘 굴러간다는 의미가 된다. 그러니 효율적으로 앱을 개발하기 위해서는 iOS 시스템의 기본 구조와 동작 원리를 잘 이해해야 한다. 우리가 운영체제를 열심히 공부하는 이유와도 비슷하다.

## 앱의 기본 구조

### 엔트리 포인트와 앱의 초기화 과정

오브젝티브-C도 C를 뿌리로 하고 있기에 main() 함수로부터 앱이 시작된다. 이를 엔트리 포인트(Entry Point, 시작점)이라고 한다. iOS 앱은 우리가 main() 함수를 작성하지 않고 Xcode 프로젝트를 생성하면 자동으로 만들어진다. 여기에는 이미 앱이 실행될 때 필요한 내용이 작성되어 있어서 우리는 main() 함수를 전혀 건드릴 필요가 없다. 

다음은 실제로 오브젝티브-C 기반의 Xcode 프로젝트를 생성했을 때 main.m 파일 안에 생성되는 main() 함수이다.

```objective-c
#import <UIKit/UIKit.h>
#import "AppDelgate.h"

int main(int argc, char* argv[]) {
  @autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}
```

main() 함수가 하는 일은 실행 시 시스템으로부터 전달받은 두 개의 인자값과 AppDelegate 클래스를 이용하여 UIApplicationMain() 함수를 호출하고, 그 결과로 UIApplication 객체를 반환한다. 이렇게 생성된 UIApplication 객체는 UIKit 프레임워크에 속해 있으므로 이후의 앱 제어권은 UIKit 프레임워크로 이관된다.

main() 함수가 C 기반 애플리케이션의 엔트리 포인트라면, UIApplicationMain() 함수는 그 중에서도 iOS 앱에 속하는 부분의 엔트리 포인트라고 할 수 있다. 앱이 동작하는데 핵심적인 객체들을 생성하는 프로세스를 핸들링하고 우리가 생성하고 작성하는 파일, 커스텀 코드를 호출해 줘 앱 생성 초기에 필요한 설정을 구현할 수 있게 해준다. 또 이벤트 루프를 실행시키기도 한다.

그리고 UIApplicationMain() 함수가 생성해서 반환하는 UIApplication 객체는 앱의 본체라고도 할 수 있는 객체다. 커스텀 코드나 객체, 앱 기능의 모든 것들이 UIApplication에 포함되어 있는 하위 객체이다. 그래서 디바이스에서 앱을 실행시키면 메모리에 올라가는 프로세스가 곧 이 UIApplication 객체라고 봐도 무방하다.

이 UIApplication 객체는 다양한 역할을 가지고 있고 우리는 이 클래스를 특별한 일이나 중대한 목적이 없다면 상속받는 것 없이 그대로 사용한다. 하지만 이 클래스를 그대로 상속 없이 사용하기에는 한계가 있다. 우리의 의도와 목적에 맞게 특별히 처리해야할 것도 있을 수 있기 때문이다. 그래서 UIApplication 객체는 AppDelegate라는 대리 객체을 두고 커스텀 코드를 처리할 수 있도록 약간의 권한을 준다. 이 AppDelegate 객체는 위임받은 일부 권한으로 커스텀 코드와 상호작용하는 역할을 담당하고, 우리가 필요한 코드를 구현할 수 있도록 도와준다. 예를 들어 앱이 최초 실행될 때 로드하는 과정을 마치는 순간에 AppDelegate 객체의 application(_:didFinishLaunchingWithOptions:) 메소드를 호출되는데, 이 메소드 안에 우리가 원하는 커스텀 코드를 작성해두면 실행이 되는 식이다. 그래서 앱을 실행시켰을 때 5초 정도 기다렸다가 실행되도록 sleep(5) 같이 적어줄 수 있는 것이다.

이 AppDelegate 객체는 iOS 앱 내에서 오직 하나의 인스턴스만 생성되도록 보장받는다. 그래서 앱이 시작될 때 생성되고 실행되는 동안 유지되고, 앱이 종료될 때 그때 함께 소멸된다. 이런 특징으로 AppDelegate 객체 내에 데이터를 저장하면 앱이 종료될 때까지 계속 데이터를 유지할 수도 있다. 그래서 AppDelegate 객체는 종종 앱의 초기 데이터 구조를 설정하기 위해 사용되기도 한다.

UIApplication 객체와 AppDelegate 객체가 연관되어 앱이 실행되는 전체 과정을 정리하면 다음과 같다.

> 1. main() 함수가 실행됨
> 2. main() 함수는 다시  UIApplicationMain() 함수를 호출함
> 3. UIApplicationMain() 함수는 앱의 본체에 해당하는 UIApplication 객체를 생성함
> 4. UIApplication 객체는 Info.plist 파일을 바탕으로 앱에 필요한 데이터와 객체를 로드함
> 5. AppDelegate 객체를 생성하고 UIApplication 객체와 연결함
> 6. 이벤트 루프를 만드는 등 실행에 필요한 준비를 진행함
> 7. 실행 완료 직전, 앱 델리게이트의 application(_:didFinishLaunchingWithOptions:) 메소드를 호출함

반면 스위프트는 C 기반의 언어가 아니기에 main.m 파일이 존재하지 않고 엔트리 포인트 역시 존재하지 않는다. 그래서 스위프트에서는 위의 1~5의 과정을 다음과 같은 어노테이션 표기로 대체한다.

```swift
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

  func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }
  ...
  ...
}
```

iOS 시스템은 앱을 실행할 때 이 어노테이션(@UIApplicationMain)이 표시된 클래스를 찾아 델리게이트로 지정한다. 이후 진행되는 나머지 과정은 동일하다.

application(_:didFinishLaunchingWithOptions:) 메소드가 호출되고 앱이 실행되고 나면, 시스템 프레임워크의 이벤트 루프가 실행되면서 우리가 작성하는 이벤트 핸들에 의해 커스텀 코드로 연결된다. 여기서 말하는 이벤트 핸들은 @IBAction 메소드 등과 같은 것을 말한다. 일종의 콜백함수 개념.

이외에도 앱의 생명주기와 관련하여 여러 메소드들이 존재한다(앱이 메모리에서 제거될 때 호출되는 applicationWillTerminate(_:) 등과 같이).

## 앱의 상태 변화(= Life Cycle)

앱의 상태는 우리가 관여하는 영역이 아닌, 운영체제가 처리하는 영역이다. 예를 들어 사용자가 앱을 사용하던 중 전화가 오면 실행되던 앱은 꺼지듯 화면에서 사라지고 전화 화면이 대체하게 되는데, 이는 iOS가 전화라는 상황에 맞게 기존 앱의 상태를 변경한 것이다. 이처럼 iOS는 앱마다 모두 상태 변화를 제어하여 실행, 홈화면으로 내리고, 종료 등 처리한다. 다음은 iOS에서 앱이 가질 수 있는 상태값은 다음과 같다.

![iOS App's life cycle](https://docs-assets.developer.apple.com/published/95ed05c755/30f48607-bf65-42cf-983f-38a55bdd0d6a.png)

![iOS App's Life cycle](https://docs-assets.developer.apple.com/published/f55402f424/9dfc33e2-1072-4d21-88d9-34ad894b615f.png)

(위 이미지는 앱의 라이프 사이클을 scene으로 나타낸 것(스토리보드의 씬과 다르다). iOS 13 이상부터 지원하는 앱 기능중 scene이라는 기능이 새로 생김. 하나의 앱에서 여러 씬을 만들고 각 씬은 서로 다른 상태, 다른 라이프 사이클을 가질 수 있음)

(아래 이미지가 일반적인 앱 라이프사이클.)

* Not Running: 앱시 시작되지 않았거나 실행되었지만 시스템에 의해 종료된 상태
* Inactive: 앱이 전면에서 실행 중이지만, 아무런 이벤트를 받지 않고 있는 상태(active로 가는 중)
* Active: 앱이 전면에서 실행 중이며, 이벤트를 받고 있는 상태
* Background: 앱이 백그라운드에 있지만 여전히 코드가 실행되고 있는 상태. 대부분의 앱은 이 단계를 Suspended로 가기 전에 스쳐지나가듯 지나가지만, 파일 다운로드나 업로드, 연산처리, 음악 실행 등 여분의 실행 시간이 필요한 앱의 경우 특정 시간 동안 이 상태로 남아있게 되는 경우도 있음
* Suspended: 앱이 메모리에 유지되지만 실행코드가 없는 상태(홈화면에서 켜진 앱들 보면 멈춰있는 그런 상태). 메모리가 부족해지면 iOS 시스템은 포그라운드에 있는 앱의 여유 메모리 공간을 확보하기 위해 Suspended 상태에 있는 앱들을 특별한 알림 없이 정리한다.

앱은 특정한 순간에 위 상태 중 하나일 수도 있고, 하나의 상태에서 다른 상태로 옮겨가는 중일 수도 있다. 

앱의 실행 상태가 변화할 때마다 앱 객체는 앱 델리게이트에 정의된 특정 메소드를 호출한다. 그리고 이 메소드 내부에 적절한 커스텀 코드를 작성함으로써 우리가 원하는 작업이 실행되도록 할 수 있다. 앱이 종료되기 전에 데이터 저장이라든지, 앱이 백그라운드 상태로 내려갔을 때 메모리 정리를 한다든지 등이다. 

앱 상태에 따른 여러 가지 메소드들은 UIAppDelegateProtocol의 공식 문서를 참고하자. [공식문서](https://developer.apple.com/documentation/uikit/uiapplicationdelegate)

## 코코아 터치 프레임워크

iOS에서 제공하는 아이폰용 앱 개발에 사용되는 프레임워크이다. (Spring처럼 정교하게 잘 만들었으니 프레임워크의 전체적인 부분을 잘 이해하는 것이 앱을 제작하는 데 중요하다). 코코아 터치 프레임워크에는 UIKit 프레임워크, 파운데이션 프레임워크, WebKit 프레임워크 등이 있다. 앱을 만들고 실행할 때 필요한 iOS 기반 기술들은 모두 코코아 터치 프레임워크를 통해 구현된다.

운영체제의 역할이 그렇듯이, iOS도 디바이스마다 다른 하드웨어에 대해서 제어를 인터페이스로 제공해주는 역할을 한다. 그래서 개발자들은 하드웨어의 구체적인 동작방법을 알 필요 없이, iOS가 추상화해준 인터페이스를 통해서 개발을 할 수 있는 것이다. 그리고 이 iOS 인터페이스가 바로 코코아 터치 프레임워크니, 무엇보다도 코코아 터치 프레임워크를 잘 이해하는 것이 곧 아이폰 앱을 잘 개발할 수 있다고 볼 수 있다.

코코아 터치 프레임워크는 여러 가지 프레임워크들을 하위로 가지고 있는데 그중 양대산맥이 바로 UIKit 프레임워크와 파운데이션 프레임워크이다. 둘은 그 자체만으로 굉장히 내용이 많고 앱을 개발할 때 필수적이기 때문에 이 둘을 주 코코아 터치 프레임워크의 주 프레임워크로 간주한다. UIKit는 유저 인터페이스 도구를 통해 iOS 앱을 구현할 수 있는 방법을 제공하고, 파운데이션은 기본 데이터 형식, 컬렉션 및 앱의 기본 객체와 기반 기술을 제공하는 역할을 한다.

#### 코코아 프레임워크와 코코아 터치 프레임워크

> 코코아 프레임워크는 맥용 앱을 제작할 때 사용되는 프레임워크이다. 기존에 애플에는 OS X를 사용하는 매킨토시 데스크톱이 전부였다. 그래서 코코아 프레임워크에는 Appkit 프레임워크와 파운데이션 프레임워크가 양대산맥이었다(Appkit은 코코아 터치 프레임워크의 UIKit처럼 데스크톱용 UI를 담당). 이후 아이폰이 등장하고, 기존 코코아 프레임워크를 사용하기에는 많은 부분이 달라서 기존 것을 기반으로 코코아 터치 프레임워크가 생긴 것이다. 그래서 현재에도 둘은 많은 부분을 공유한다. 예를 들어 파운데이션 프레임워크는 둘 다 공유해서 사용한다.

## 프레임워크 계층 관계

코코아 터치 프레임워크에도 계층이 존재한다. 상위일수록 보다 추상화가 잘되어 있고 개발자가 사용하기 쉽다. 반면 하위로 갈수록 프레임워크는 하드웨어에 가까워져서 개발자가 다룰 수 있는 게 많아지지만 그만큼 번거로워 진다.

이러한 계층 구조 덕분에 앱을 개발할 때 로우 레벨에 대한 이해가 없어도 상위 프레임워크만을 통해 원하는 결과물을 쉽게 구현할 수 있다.

하지만 앱 개발 시 전적으로 상위 계층의 프레임워크만 사용하는 것은 아니다. 경우에 따라서 상위 레벨의 프레임워크가 지원하지 않는 기능을 구현해야 하는데 이 경우에는 하위 프레임워크를 사용하여 기능을 구현해야하기 때문이다. 그러니 어플리케이션 기능을 확정하기 위해서는 하위 프레임워크에 대한 구조와 사용 방법까지 충분히 숙지하고 있어야 한다.

iOS 프레임워크의 계층 관계는 다음과 같다(아래 계층들 설명은 책의 내용을 거의 그대로 옮김).

![iOS Framework hierarchy](https://static.packt-cdn.com/products/9781849691307/graphics/1307_01_01.jpg)

### 코어 OS 계층

코어 OS 계층에는 커널, 파일 시스템, 네트워크, 보안, 전원 관리, 디바이스 드라이버 등이 포함되어 있다. iOS가 운영체제로서 기능을 하기 위한 핵심적인 영역.

### 코어 서비스 계층

이 계층에 속한 프레임워크들은 문자열 처리, 데이터 집합 관리, 네트워크, 주소록 관리, 환경설 정 등 핵심적인 서비스들을 제공함. 또한 GPS, 나침반, 가속도 센서나 자이로스코프 센서와 같이 디바이스 하드웨어 특성에 기반한 서비스도 제공함. 이 계층에 포함되어 있는 대표적인 프레임워크는 파운데이션 프레임워크와 파운데이션 프레임워크가 내부적으로 의존하는 코어 파운데이션 프레임워크가 있음. 이 밖에도 Core Location, Core Motion, Core Animation 등의 프레임워크와 Core Data 프레임 워크도 이 계층에 포함됨.

### 미디어 계층

여기에 속한 프레임워크는 하위의 코어 서비스 계층이 의존적이며, 상위 계층인 코코아 터치 계층에 그래픽 관련 서비스나 멀티미디어 관련 서비스를 제공함. 대표적인 프레임워크로는 코어 그래픽스, 코어 테스트, 코어 오디오, 코어 애니메이션, AV파운데이션 등이 있다. 쉽게 생각해서 mp4와 같은 비디오 파일을 아이폰에서 재생할 때 미디어 계층이 관여한다고 보면 됨

### 코코아 터치 계층

코코아 터치 계층은 애플리케이션 프레임 워크 계층이라고도 불리며, 애플리케이션을 직접 지원하는 역할을 담당. iOS에 설치되고 실행되는 모든 앱은 코코아 터치 계층에서 제공하는 여러 가지 기술이나 서비스를 이용하여 기능을 구현하고 동작함. 코코아 터치 프레임 워크의 양대 산맥인 UIKit가 이 계층에 속해 있으며 Game Kit, Map Kit 등의 프레임워크들 역시 여기에 속함

# 앱을 구성하는 핵심 객체들

## iOS 유저 인터페이스의 표현 구조

iOS는 항상 디바이스 스크린에 꽉 들어가는 하나의 화면만을 표시할 수 있고, 다른 앱이 실행되면 기존 앱 화면이 내려가고 그 자리를 새로운 화면이 채운다. 이런 과정에 윈도우와 뷰 객체가 사용된다.

우선 윈도우 객체는, iOS에서 스크린을 빈틈없이 채우기 위한 객체로 항상 유저 인터페이스 표현 계층의 최 상위에 위치한다. 뷰의 일종이지만 표시하는 컨텐츠는 가지지 않고 대신 컨텐츠를 가진 뷰를 내부에 배치하여 화면에 출력하는 역할을 한다. 화면이 바뀌더라도 실제로는 윈도우 객체는 그대로 있고 단지 내부에 배치된 뷰의 콘텐츠만 변경되는 것이다. 즉 배경같은 역할로 앱이 실행되는 동안 쭉 화면을 채우고 있는 것. 실제 출력 내용은 내부에 배치된 뷰들이다.

뷰는 콘텐츠를 담아서 스크린상에 표시하고, 사용자 입력에 반응한다. 윈도우의 일부를 자신의 영역으로 정의하고 여기에 필요한 콘텐츠를 채워 넣어 스크린에 나타내는 동시에 윈도우로부터 전달된 사용자의 입력에 반응하여 그에 맞는 결과를 처리한다. 뷰는 텍스트나 이미지, 도형, 네비게이션 바, 탭 바 등이 결합하여 다양한 형태의 뷰를 화면에 나타낸다. 영역이 겹쳐질 경우 중첩된 형태로 표현되기도 한다.

![ios window and view architecture](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Art/view-layer-store.jpg)

iOS에서 실행되는 모든 앱은 최소한 하나 이상의 윈도우와 뷰를 가진다. 다만 외부 디스플레이가 연결될 경우 앱은 두 번째 디스플레이에 콘텐츠를 표시하기 위해 새로운 윈도우 객체를 생성한다.

윈도우와 뷰는 뷰 컨트롤러를 통해 연결된다. 뷰 컨트롤러는 뷰의 계층을 관리하여 윈도우에 전달하고, 디바이스에서 감지된 터치 이벤트를 윈도우로부터 전달받아 처리하는 역할을 한다. 윈도우가 뷰를 직접 참조하지 않고 뷰 컨트롤러가 그 사이를 중계하는 구조 덕분에 윈도우는 뷰 컨트롤러를 통해 제공되는 뷰를 읽어서 표현할 뿐, 뷰를 직접 관리하지 않아도 된다. 이는 윈도우 객체에 커스텀 코드가 난립하는 것을 차단하며, 앱이 표현해야 하는 모든 뷰를 윈도우 객체 하나가 관리해야하는 불상사를 막아준다.

### 루트 뷰 컨트롤러

윈도우 객체는 하나의 뷰 컨트롤러를 루트 뷰 컨트롤러로 지정하여 참조한다. 나머지 루트로 지정되지 않은 뷰 컨트롤러들은 루트 뷰 컨트롤러의 관리 대상으로 연결되거나 혹은 다른 방식으로 이어지기도 하지만, 윈도우 객체는 이들을 관리하지 않는다. 윈도우 객체는 항상 루트 뷰 컨트롤러만을 참조한다.

#### 콘텐츠 뷰 컨트롤러

우리가 스토리보드를 통해 편집하는 대부분의 뷰 컨트롤러들은 각자가 하나씩의 화면을 담당하여 콘텐츠를 표현하고 뷰를 관리하는데, 이를 **씬(Scene)**이라는 용어로 부른다. 이렇게 씬을 담당하고 콘텐츠를 표시하는 뷰 컨트롤러를 콘텐츠 **뷰 컨트롤러(Contents View Controller)**라고 한다.

#### 컨테이너 뷰 컨트롤러

하지만 일부 특별한 뷰 컨트롤러는 씬을 표현하는 대신 다른 뷰 컨트롤러의 연결 관계를 관리하기도 한다. 내비게이션 컨트롤러나 탭 바 컨트롤러, 페이지 컨트롤러 등이 대표적인 예이다. 이들을 콘텐츠 뷰 컨트롤러와 구분하여 컨테이너 **뷰 컨트롤러(Container View Controller)**라고 한다.

#### View Hierarchy - https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/TheViewControllerHierarchy.html

뷰 컨트롤러 내부는 수많은 뷰들로 이루어진다. 이들 뷰는 자기 자신을 스크린상에 표시하기도 하면서 동시에 다른 뷰 객체를 포함하는 컨테이너의 역할도 수행하는데 이를 **뷰 계층구조(View hierarchy)**라고 한다. 뷰의 계층 구조 상에서 다른 뷰를 포함하는 뷰는 **슈퍼뷰(superview)**가 되고, 슈퍼 뷰에 포함된 뷰는 **서브 뷰(subview)**가 된다. 슈퍼 뷰는 곧 서브 뷰가 될 수 있고, 서브 뷰도 어떤 뷰에겐 슈퍼 뷰가 될 수 있다. 중요한 점은 서브 뷰는 슈퍼 뷰를 기준으로 레이아웃을 구성하고, 슈퍼 뷰는 서브 뷰가 레이아웃을 구성할 수 있도록 내부적으로 원점을 포함하는 좌표 체계를 제공한다는 점이다. 그래서 뷰의 계층 구조에서 뷰들은 서로 상대적인 레이아웃을 이룬다.

일반적으로 각각의 씬은 자신만의 뷰 계층 구조를 가지고 있으며, 뷰 계층 구조 최상위에는 하나의 뷰가 존재한다. 이 뷰를 **루트 뷰(Root View)** 또는 **콘텐츠 뷰(Contents View)**라고 한다. 테이블 뷰 컨트롤러에서는 테이블 뷰가 루트 뷰이며, 컬렉션 뷰 컨트롤러에서는 컬렉션 뷰가, 일반 뷰 컨트롤러에서는 View 객체가 루트 뷰의 역할을 담당한다. 일반적으로 뷰는 다양한 크기를 가질 수 있지만 루트 뷰는 항상 화면 전체를 채울 수 있는 크기를 유지한다.

루트 뷰 내부에는 각자의 크기와 콘텐츠를 가진 여러 개의 서브 뷰가 추가되는데 일부 뷰의 영역은 서로 겹치기도 한다. 루트 뷰는 이런 서브 뷰들을 모아 하나의 전체 뷰를 구성하고, 뷰 컨트롤러를 통해 이를 윈도우에 전달한다. 아래 그림은 윈도우 객체와 뷰 컨트롤러, 그리고 루트 뷰의 참조 관계를 보여준다.

![iOS window and view controller](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG-root-view-controller_2-1_2x.png)

## 뷰 컨트롤러

View Controller는 앱의 근간을 이루는 객체로, 모든 앱은 최소한 하나 이상의 뷰 컨트롤러로 구성된다. 뷰 컨트롤러의 주된 역할은 뷰를 관리하는 것이지만 단순히 여기서 그치지 않고 화면과 데이터 사이의 상호 작용까지 관리하기도 한다. 윈도우 객체로부터 전달된 이벤트를 받아 내부적으로 구현된 비지니스 로직을 실행하고 그 결과로 얻어진 데이터를 콘텐츠로 만들어 화면으로 표현하는 등, 모바일 앱에서 뷰 컨트롤러는 우리가 하는 대부분 작업들의 중심에 있다. 주요 컨트롤러는 다음과 같다

| 컨트롤러            | 기능                                               | 구현클래스             |
| ------------------- | -------------------------------------------------- | ---------------------- |
| 뷰 컨트롤러         | 화면을 구성하고 콘텐츠를 표현하는 기본 뷰 컨트롤러 | UIVIewController       |
| 내비게이션 컨트롤러 | 화면의 이동과 계층적 탐색을 위한 컨트롤러          | UINavigationController |
| 테이블 뷰 컨트롤러  | 목록을 구현하기 위한 컨트롤러                      | UITableController      |
| 탭 바 컨트롤러      | 병렬적 화면을 탭으로 구분하기 위한 컨트롤러        | UITabbarController     |
| 스플릿 뷰 컨트롤러  | 메인 - 서브 화면 분할용 컨트롤러(아이패드처럼)     | UISplitViewController  |

뷰 컨트롤러가 맡고 있는 역할은 무척 다양하지만 그중에서도 뷰의 계층을 관리하는 역할은 특히 중요하다. 뷰 컨트롤러에는 컨트롤러 내부에 있는 모든 객체의 대장 격인 루트 뷰 하나가 존재하는데, 일반 뷰나 테이블 뷰, 컬렉션 뷰 등 다양한 뷰가 루트 뷰로 지정이 될 수 있다. 스토리보드에서 뷰 컨트롤러 위에 배치하는 대부분의 객체들은 실제로는 모두 루트 뷰에 추가되는 서브 뷰라고 할 수 있다.

우리는 항상 모든 객체를 루트 뷰 혹은 그 아래에 추가해야한다. 루트 뷰 없이 곧바로 객체를 뷰 컨트롤러에 추가할 수는 없다. 다음 그림은 뷰 컨트롤러와 뷰 사이의 참조 관계를 보여준다. 뷰 컨트롤러로부터 가장 하위의 서브 뷰에 이르기까지 계층 구조를 따라 참조가 체인처럼 이어지기 때문에 뷰 컨트롤러가 하위의 모든 뷰에 대한 참조를 가지고 있지 않아도 모든 뷰에 접근할 수 있다.

![view controller and view](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/Art/VCPG_ControllerHierarchy_fig_1-1_2x.png)

## 뷰 컨트롤러의 상태 변화와 생명 주기

뷰 컨트롤러의 생명 주기는 씬(Scene)의 전환과 복귀에 밀접하게 연관되어 있다. 일반적으로 새로운 장면으로 전환하거나 이전 화면으로 복귀하는 과정에서 뷰 컨트롤러의 객체의 생성과 소멸이 발생한다.

앱을 처음 실행하거나 새로운 장면으로 전환할 때에는 그 장면을 담당하는 뷰 컨트롤러 객체가 새로 생성된다. 생성된 객체는 메모리에 로드되어 자신의 역할을 수행하다가 앱이 이전 장면으로 복귀하면 생성된 뷰 컨트롤러 객체는 메모리에서 해제되면서 소멸한다. 이후 필요에 의해서 다시 그 장면으로 전환할 경우 뷰 컨트롤러 객체는 이미 소멸된 후이기 때문에 다시 새롭게 생성되고, 역할을 끝내면 다시 소멸한다.

얼핏 보면 뷰 컨트롤러의 생명주기가 단순해보이지만 실상은 더 복잡하다. 생성된 상태나 소멸된 상태 사이에도 다양하고 세부적인 상태가 여럿 존재하기 때문이다. 예를 들어 다른 장면이 현재의 장면을 덮어 화면에서 사라진 상태, 자신의 위를 덮은 다른 장면을 걷어내고 다시 자신이 현재의 스크린에 표시되는 상태가 대표적이다. 뷰 컨트롤러 클래스에 정의된 관련 메소드들을 찾아보면 뷰 컨트롤러의 생명 주기도 상당한 수준으로 세분화되어 있다는 것을 알 수 있다.

뷰 컨트롤러는 생성된 후에 계속해서 다른 뷰 컨트롤러와의 상호관계에 의해 동작하거나 하드웨어, OS의 제어에 의해 움직이게 된다. 이때 화면 상태에 따라 메모리를 효율적으로 관리하기 위해서는 세부적인 제어, 일명 튜닝이 필요하다. 예를 들어, 타이머나 스톱워치의 경우 화면에서 지속적으로 남은 시간 또는 경과 시간을 갱신해서 표시해야한다. 하지만 만약 이 화면이 다른 화면에 덮인 상태라면 굳이 화면을 갱신하고 있을 필요가 없다. 사실 남은 시간이나 경과 시간이 얼마인지도 세지 않고 있어도 된다. 스크린에 다시 화면이 표시될 때 한꺼번에 계산해서 경과 시간을 처리해버리면 된다. 이외에도 앱의 화면 상태에 따라 적용할 수 있는 메모리 관리 기법들은 매우 많다.

앱의 생명 주기에 따라 호출되는 앱 델리게이트의 메소드들이 정해져 있었던 것처럼, 뷰 컨트롤러가 특정 상태 변화를 일으킬 때에도 뷰 컨트롤러에 호출하는 메소드들이 정의되어 있다.

![View controller lifecycle](https://developer.apple.com/library/archive/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Art/WWVC_vclife_2x.png)

그림에 따르면 뷰 컨트롤러는 다음과 같이 네 가지 상태로 나눌 수 있다.

* Appearing: 뷰 컨트롤러가 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태임. 퇴장 중인 다른 뷰 컨트롤러와 교차하기도 하며, 이때 퇴장 중인 다른 뷰 컨트롤러의 상태는 Disappearing이 됨.
* Appeared: 뷰 컨트롤러가 스크린 전체에 완전히 등장한 상태를 나타냄
* Disappearing: 뷰 컨트롤러가 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태, 또는 퇴장하기 시작해서 완전히 퇴장하기 직전까지의 상태임. 이 상태의 뷰 컨트롤러는 새로 등장할 뷰 컨트롤러와 교차하기도 하며, 이때 등장 중인 다른 뷰 컨트롤러의 상태는 Appearing 임.
* Disapeared: 뷰 컨트롤러가 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태를 나타냄.

뷰 컨트롤러는 위의 상태 변화를 반복한다. Appearing 상태를 거쳐 Appeared 상태로 진행되고, 다시 Disappearing 상태를 거쳐 Disappeared 상태로 진행된다. 종종 Appearing 상태에서 바로 DisAppeared 상태로 가는 경우도 있는데 이는 뷰 컨트롤러가 화면에 등장하는 도중에 다시 퇴장할 수도 있음을 의미한다.

특이한 것은 위 상태값의 일부는 완료가 아니라 진행 중인 상태를 나타내기도 한다는 점이다. 처음에 뷰 컨트롤러의 뷰가 화면에 등장하면 Appearing 상태를 거쳐  Appeared 상태로 이전된다. 만약 여기서 화면 이동이 발생한다면 기존 화면은 퇴장하고 새로운 화면이 등장하는데, 이때 기준 화면은 Disappearing 상태를 거쳐  Disappeared 상태로 변화한다. 사용자가 홈버튼을 눌러 앱을 백그라운드 상태로 보냈을 때도 마찬가지로 화면이 퇴장하는 상태 변화가 발생한다. 단, 이때에는 다른 뷰 컨트롤러와 교차하지 않는다.

이 과정은 중간 단계 없이 한 번에 바로 진행되기도 하지만, 애니메이션을 적용할 경우 수 초에 걸쳐 천천히 진행된다. 이 때문에 진행 중에 있는 상태를 나타내는 상태값인 Appearing, Disappearing이 필요한 것이다.

Disappearing 상태눈 두 가지 경우로부터 만들어진다. 하나는 새로운 뷰 컨트롤러가 등장하여 현재의 화면을 덮는 경우이다. 이때에는 Disappeared 상태로 진행되었다가, 미래의 어느 순간에 다시 Appearing 상태로 진행될 수 있다. 사용자가 새로운 뷰 컨트롤러를 걷어낸다면 기존의 뷰 컨트롤러가 다시 화면에 나타내기 때문이다. 

또 다른 경우는 이전 화면으로 되돌아가기 위해 현재의 뷰 컨트롤러가 사라지는 경우이다. 이때에는 Disappeared 상태로 진행되었다가 미래의 어느 순간에 메모리에서 소멸된다.

이러한 뷰 컨트롤러의 상태에 따라 viewWillAppear(_:), viewDidAppear(_:) 등의 메소드가 호출된다. 이러한 메소드들은 공식 doc을 보자. 중요한 것은 이 생명 주기를 잘 이해해서 각 상태 변화 시 호출되는 메소드들을 잘 파악해 놓는 것이다. 

**View Controller Method** https://developer.apple.com/documentation/uikit/uiviewcontroller

