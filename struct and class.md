# 구조체와 클래스

비슷함.

프로퍼티, 메소드, 서브스크립트, 초기화 블록, 확장(extends), 프로토콜은 공통점. 상속, 타입 캐스팅, 소멸화 구문, 참조에 의한 전달은 클래스만 존재.

네이밍 룰은 클래스 이름은 카멜케이스, 멤버들은 소문자로 시작하는 카멜 케이스(파스칼).

구조체에만 멤버와이즈 펑션(Memberwise Function)가 기본적으로 생성됨. 이 메소드는 모든 프로퍼티를 인자로 받아서 초기화 하는 메소드임

모든 프로퍼티는 초기화되어 있어야 빈 괄호 생성자를 사용할 수 있음 + 객체가 초기화 될 때는 모든 프로퍼티가 초기화되어있어야 함.

그나마 옵셔널 타입의 프로퍼티는 선언만 해도 nil 값으로 초기화되니 상관 없음.

## 구조체 값 전달 방식: Call By Value

구조체를 다른 변수나 상수에 대입하면 구조체에 있는 모든 값을 복사하여 새로운 객체를 만들어 대입함. 새로운 객체가 생성되는 것.

약간 눈여겨봐야할 점은, 구조체 인스턴스를 상수에 할당하면 프로퍼티 값을 변경할 수 없게 된다. 이는 인스턴스가 변수나 상수에 할당될 때 구조체 인스턴스에 정의된 프로퍼티 전체 값이 그대로 복사되는 구조여서 할당된 이후에 프로퍼티 값이 변경되면 저장된 값 자체가 변경되는 것으로 인식하기 때문.

## 클래스 값 전달 방식: Call By Reference

클래스 인스턴스는 참조로 값을 전달한다. 그래서 메모리를 해제할 때 다른 곳에서 더 이상 쓰고 있진 않는지를 잘 검사해야한다(번거롭지..). Object-C에서는 개발자가 했지만 스위프트에선 ARC(Auto Reference Counter) 객체를 통해서 이를 관리한다. '지금 클래스 인스턴스를 참조하는 곳이 모두 몇 군데인지 자동으로 카운트해주는 객체'이다.

추가로 봐야할 건, 클래스 인스턴스 간의 비교이다. 클래스는 참조타입이기 때문에 단순한 값 비교는 불가능하다. 그래서 같은 메모리 공간인지를 비교하는 연산자가 있는데, ===, !== 이다. 클래스 인스턴스의 주소를 보고 동일한 인스턴스인지 다른 인스턴스인지를 검사한다.

```swift
class VideoMode {
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

let vs = VideoMode()
let ds = vs
let ts = VideoMode()
// 동일한 객체 참조
if vs === ds {
    print("vs와 ds는 동일한 VideoMode를 참조하고 있습니다.")
} else {
    print("vs와 ds는 서로다른 VideoMode를 참조하고 있습니다.")
}

// 서로 다른 객체 참조
if vs === ts {
    print("vs와 ds는 동일한 VideoMode를 참조하고 있습니다.")
} else {
    print("vs와 ds는 서로다른 VideoMode를 참조하고 있습니다.")
}
```

