# GCD(=Dispatch)

멀티코어 하드웨어에서 동시성(concurrent) 코드 실행을 위해 애플이 제공하는 프레임워크. 한 앱에서 여러 개의 코어를 효율적으로 사용하기에는 어려움. GCD를 통해서 이를 더 쉽게 관리할 수 있음.  
  
예를 들어 앱을 개발할 때, UI는 계속 사용자에게 바로바로 반응해줘야 함. 이때 다른 무거운 작업을 하면서 코어를 점유하고 있으면 UI가 반응을 못하겠지. 해결법으론 UI만 담당하는 우선권 높은 메인 쓰레드, 나머지 무거운 작업을 하는 쓰레드로 나눠서 동시성 있게 코드를 실행하는 것이 있음. 이외에도 앱을 더 빠르고, 효율적이고 반응성 있게 개발할 때 여러 쓰레드를 사용할 수도 있음. 근데 그러면 이 쓰레드를 생성, 삭제, 관리하는 건 누가하는가? 이를 프로그래머가 직접 하기에는 복잡하고 매우 어려움. 때문에 개발자들은 GCD에서 제공하는 DispatchQueue를 사용하면 되는 것. 이 큐를 사용하면 GCD가 알아서 스레드 생성, 관리하고 작업을 적절하게 스레드에게 배분해줌. 그러니 개발자는 GCD가 작업을 관리하는 방식, DispatchQueue의 작업 배분 방식, 몇몇 주의사항(데드락 발생 안시키게) 등등을 잘 알고 있으면 직접 스레드를 생성, 관리할 때보다 훨씬 쉽고 효율적으로 동시성 프로그래밍을 수행할 수 있을 것임.  

## Sync, Async, Serial, Concurrent  
흔히 DispatchQueue를 활용할 때 자주 보이는 키워드 4가지. 이 4가지를 헷갈리지 않게 잘 이해해야 함.  
Sync와 Async는 함수 호출할 때 동기인지 비동기인지를 구분하는 것임. Sync는 함수 호출을 동기적으로 하는 것임. 그래서 함수가 모두 작업을 마치고 리턴할 때까지 다음 코드를 실행시키지 않고 기다림. 반면 Async는 함수 호출을 비동기적으로 하는 것으로, 함수 호출 직후 기다리지 않고 바로 리턴해버리고 다음 코드를 실행함(보통 해당 함수가 일을 마쳤는지는 콜백을 통해 알림을 받곤 함). Sync와 Async는 DispatchQueue에 Task를 넘길 때, 이 Task가 끝나는 걸 기다릴지(Sync), 안 기다릴지(Async)임을 의미함.  

Serial과 Concurrent는 DispatchQueue의 속성이라고 할 수 있음. Serial Dispatch Queue는 큐에 들어온 작업을 순서대로 처리+끝내는 것을 의미. 때문에 큐가 관리하는 작업들에 동시에 단 하나만 처리되고 있음을 보장함(이때 이 작업이 계속 동일한 스레드에서 작업되는 것을 보장해주진 않음. GCD가 관리하기에 자기 맘대로라고 할 수 있음). 그래서 큐에 들어온 순서대로 작업이 시작되고, 끝남. 반면 Concurrent Dispatch Queue는 이름처럼, 동시에 여러 개의 작업을 수행함. 때문에 작업을 시작하는 순서만 보장되고(큐에 들어온 순서대로 작업이 시작될 것임) 각 스레드가 작업을 나눠가질 것이니 작업이 끝나는 타이밍은 작업마다 다 다를 수 있음.  

## DispatchQueue 종류    
DispatchQueue는 위에서 언급했듯, 동시성 프로그래밍을 할 때 GCD에게 작업 관리를 맡길 때 사용하는 큐라고 할 수 있음. 프로그래머는 이 큐에다가 작업을 넣어두고, GCD가 요청사항에 맞춰서 스레드에 작업 배분하고 수행.   
DispatchQueue는 크게 3가지 종류로 나뉨. Main, Global, Private. 메인은 UI를 담당하는 시리얼 큐. 메인스레드 단 하나만을 사용한다. Global은 concurrent 큐이며 qos에 따라 총 6개 존재(userInteractive, userInitiated, default, utility, background, unspecified 순. 이는 아래 QoS에서 다시 다룸). 마지막으로 Private은 사용자가 직접 생성하는 DispatchQueue(반대로 말하면 Main, Global은 시스템이 관리하는 큐). 기본은 concurrent로 생성되고 serial로도 생성할 수 있음. 애플은 공식문서에서 너무 많이 private concurrent queue를 생성하지 말고 global을 주로 사용하라고 권고하고 있음. 왜냐하면 앱이 너무 많은 스레드가 생성될 수 있기 때문.  


## QoS(Quality of Service)   
작업(Task)에 적용되는 실행 우선순위라고 할 수 있음. 예를 들어, UI 관련 작업들은 실행 우선순위가 높아야 함. 왜냐하면 사용자에게 반응성 있는 UI를 보여줘여 하고, 자주 호출되며, 보통 짧게짧게 호출되기 때문. 반면 네트워크 작업, 파일 작업, 백그라운드 작업은 실행 우선순위가 꼭 높을 필요는 없음. 작업을 처리하는 데에 시간이 보통 오래 걸리고, 사용자도 이를 인지하고 있으니깐.  
GCD에서는 실행 우선순위를 6가지로 나눔. 높은 우선순위대로, userInterative, userInitiated, default, utility, background, unspecified. global 큐 역시 qos대로 6개가 있음. qos대로 큐가 작업 우선순위를 갖는다고 생각하면 됨.   
그런데 DispatchQueue에 작업을 제출할 때, 작업에 대해서도 qos를 지정해줄 수도 있음. 이때 global 큐 qos보다 제춣하는 작업의 qos가 더 높다면 일시적으로 해당 큐가 작업과 동일한 우선순위로 높아져서 처리됨(처리 끝나면 다시 원상복귀). 반면 global 큐 qos보다 제출하는 작업의 qos가 더 낮다면, 그냥 큐의 qos에 맞춰서 작업이 처리됨.       

 
