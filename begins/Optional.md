# Optional

 swift에서는 오류를 최대한 발생시키지 않으면서(발생하면 프로그램이 뻗으니깐)  프로그래머에게 뭔가 문제가 있었다는 것도 알려주기 위해 **nil** 값을 사용한다. 딕셔너리에서 없는 키값을 참조할 때와 같이, 값을 처리하는 과정에 문제가 있을 경우 스위프트는 많은 부분에서 오류를 발생시키는 대신 결과값을 **nil** 로 반환한다. 하지만 모든 타입이 nil을 반환할 수 있는 것은 아니며 옵셔널 타입만 nil을 반환할 수 있다. 

중요한 점은 "오류가 발생할 가능성"이다. 아주 조금이라도 오류가 발생할 가능성이 있다면 모두 옵셔널 타입으로 정의해야 한다. 그래서 Int("Swift")는 nil을 반환한다.(숫자 변환이 안되고, 오류 발생 안시키면서 뭔가 문제가 있다는 걸 알림)

옵셔널 타입으로 선언하기 위해서는 우리가 사용하는 자료형 뒤에 물음표만 붙이면된다.

```swift
var optInt : Int?
var optStr : String?
var optDouble : Double?
var optArr : [String]?
var optDic : Dictionary<String, String>?
var optClass : AnyObject?
```

일반 자료형을 선언만 하고 초기화하면 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화된다. **물론, 옵셔널 내부에 있는 자료형에 nil값이 부여된다는 것이 아니라, 옵셔널 타입 자체에 nil이 부여된다는 뜻이다.**

옵셔널 타입끼리는 결합 연산, 더하기 연산이 가능한 데이터 타입이 아니고, 일반 자료형과 옵셔널은 다른 자료형이기 때문에 연산이 불가능

```swift
Int("123") + Int("123") // 불가. 옵셔널 + 옵셔널
Int("123") + 30 // 불가. 옵셔널 + 일반 자료형
```

그래서 옵셔널 객체를 해제하고 내부에 있는 값을 추출해야하는데, 이를 Optional Unwrapping 이라고 한다. 옵셔널 해제에는 명시적, 묵시적 해제가 있다. 각각 강제 해제, 비강제 해제와 컴파일러에 의한 자동 해제, !연산자를 사용한 자동 해제가 있다.

## Forced Unwrapping(강제 해제) 

옵셔널 타입의 값 뒤에 '!' 기호만 붙여주면 된다. 이때 사용된 '!'를 '강제 해제 연산자(Forced-Unwrapping Operator)'라고 한다.

```swift
var optInt : Int? = 3

print("옵셔널 자체의 값: \(optInt)")
print("!로 강제 해제한 값: \(optInt!)")
```

근데 실제로는 이렇게 막 강제 해제하면 안된다. nil을 강제 해제하면 오류가 발생하기 때문. 그래서 안전하게 사용하기 위해 조건이 따른다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검하고, nil이 아닐 때만 강제 해재 연산자로 추출하는 것이 안전하다.

```swift
var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr!)입니다")
} else {
    print("값 변환에 실패하였습니다.")
}
```

추가로, 여기서 intFromStr의 비교연산자 != 사이에 공백은 가독성을 위한 것이 아니라 의도적으로 넣은 것이다. 강제 해제 연산자 "!"와 구분하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야한다.

## Optional Binding

강제 해제와 동일한 기능을 하는 비강제적인 해제 구문으로 바꿀 수 있다. 이는 if 구문 내에서 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식으로, Optional Binding(옵셔널 바인딩)이라 함.(기존에 앞에서 dictionary 조회할 때 조건문에서 사용하던 특이한 문법)

```swift
var str = "Swift"

if let intFromStr = Int(str) {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr)입니다.")
} else {
    print("값 변환에 실패하였습니다.")
}
```

(if 조건문에서 바로 초기화를 해야 옵셔널 바인딩이 됨. 선언후 할당은 안됨)

아래는 guard를 활용한 옵셔널 바인딩 예시인데, if와 다르게 살아있는 범위가 함수 내임

```swift
func intStr(str: String) {
    guard let intFromStr = Int(str) else {
        print("값 변환에 실패")
        return
    }
    
    print("값 변환됨. \(intFromStr)입니다")
}
```

if 구문 내에서 옵셔널 바인딩을 사용한 것과 guard 구문 내에서 사용한 옵셔널 바인딩은 방식은 동일하지만 사용 용법상 구분할 필요가 있다. if 구문을 사용한 옵셔널 바인딩은 단순히 옵셔널 값의 처리 결과에 따라 서로 다른 피드백을 주고 싶을 때 사용. 하지만 guard 구문은 조건에 맞지 않으면 무조건 함수의 실행을 종료시키는 특성이 있기에 실행 흐름상 옵셔널 값이 해제되지 않으면 더 이상 진행이 불가능할 정도로 큰일이 생길 때에만 사용하는 것이 좋다고 함. + 옵셔널 타입이긴 하지만 절대 nil 값이 들어가지 않을 것이라는 보장이 있을 때에는 Forced unwrapping operator를 사용해서 옵셔널 타입을 처리하는 것이 효율적이라고 함.

## 컴파일러에 의한 옵셔널 자동 해제

! 연산자를 이용한 Forced Unwrapping, Optional binding 으로 명시적 해제 외에도 컴파일러에서 자동으로 옵셔널을 해제해주는 경우가 있음

```swift
let optInt = Int("123")

if optInt == 123 {
    print("optInt == 123")
} else {
    print("optInt != 123")
}
```

명시적으로 옵셔널 객체를 강제 해제하지 않아도 한쪽이 옵셔널, 다른 한쪽이 일반 타입이라면 자동으로 옵셔널 타입을 해제하여 비교 연산을 수행함. 아래에서 모든 결과는 true이다.

```swift
let tempInt = Int("123")

tempInt == 123 // true
tempInt == Optional(123) // true
tempInt == 123 // true 
tempInt! == Optional(123) // true
```

그래서 옵셔널 값을 할당할 때는 순수 리터럴을 직접 대입해도 타입 어노테이션에 옵셔널을 적으면 Optional() 객체로 감싸서 대입해준다. 원칙적으로는 옵셔널에 대입할 때 Optional()로 값을 감싸야하긴 함.

```swift
var optValue01 = Optional(123)
var optValue02 : Int? = 123
```

## 옵셔널의 묵시적 해제(Implicitly Unwrapped Optional)

타입 어노테이션에서 ? 대신 ! 를 붙여주면, 옵셔널 타입이긴 하지만 값을 사용할 때에는 자동으로 옵셔널이 해제되기 때문에 굳이 ! 연산자를 사용하여 해제할 필요가 없는 아주 편리한 구문. 컴파일러가 알아서 옵셔널을 해제해주기 때문에 앞의 자동 해제와 유사하지만 전자가 비교연산, 값을 할당 등 일부 구문에서만 한정되는 것과 달리 묵시적 해제는 옵셔널 변수를 사용하는 모든 경우에 사용할 수 있고 타입을 선언할 때 묵시적 해제를 미리 선언해주어야 한다는 차이가 있음

```swift
var str: String! = "Swift Optinal"
print(str)

var str2: String! = nil // 문제없음

var value01: Int? = 10
value01 + 5 // 오류

var value02: Int! = 10
value02 + 5 // 15
```

편리하지만 무조건 모든 경우에 사용할 수 있는 것은 아님. **변수의 값이 nil이 될 가능성이 있다면 묵시적 해제를 사용하지 않아야한다.** 묵시적 옵셔널 해제를 사용하는 경우는 한 가지로 정의된다. 

> "형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 nil 값이 대입될 가능성이 없는 변수일 때"

예를 들면 아래와 같다.

```swift
var value: Int! = Int("123")
```

이것만 보면 갸우뚱이지만, 실제로 묵시적 옵셔널이 정말 유용하게 사용되는 경우는 클래스 또는 구조체 내에서이다. 주로 멤버 변수를 정의할 때 선언과 초기화를 분리시켜야 하는 경우에 해당한다.